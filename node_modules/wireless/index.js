var util = require('util');
var events = require('events');
var _ = require('underscore');
var exec = require('child_process').exec;

// gonna require some sys or child_process stuff for executing nix commands
var Wireless = function() {
    events.EventEmitter.call(this);
    var self = this;

    self.networks = [];
    self.scanner = null;
    self.killing = false;

    // Configuration settings
    self.configuration = {
        // Interface to listen on (should one day handle multiple)
        iface: 'wlan0',
        // How often to poll the listing of networks
        updateFrequency: 10,
        // How many scans should an AP not be in the results before we consider it disappeared
        disappearThreshold: 2,
        // What commands to execute
        commands: {
            scan: 'iwlist :INTERFACE scan',
            stat: 'ifconfig :INTERFACE',
            disable: 'ifconfig :INTERFACE down',
            enable: 'ifconfig :INTERFACE up',
            interfaces: 'iwconfig',
            metric: 'ifconfig :INTERFACE metric :VALUE',
        },
        translated: {}
    };

    // Set the configuration settings
    self.configure = function(config) {
        // should actually be a merge
        _.extend(self.configuration, config);

        self.configuration.translated = {
            scan: self.configuration.commands.scan.replace(':INTERFACE', self.configuration.iface),
            stat: self.configuration.commands.stat.replace(':INTERFACE', self.configuration.iface),
            disable: self.configuration.commands.disable.replace(':INTERFACE', self.configuration.iface),
            enable: self.configuration.commands.enable.replace(':INTERFACE', self.configuration.iface),
            interfaces: self.configuration.commands.interfaces.replace(':INTERFACE', self.configuration.iface),
            metric: self.configuration.commands.metric.replace(':INTERFACE', self.configuration.iface),
        };
    };

    // Start listening
    self.start = function(callback) {
        self._executeScan();
        self.scanner = setInterval(self._executeScan, self.configuration.updateFrequency * 1000);
    };

    self._seeNetwork = function(network) {
        if (self.networks[network.address]) {
            var oldNetwork = self.networks[network.address]
            if (oldNetwork.ssid != network.ssid || oldNetwork.encryption != network.encryption) {
                self.emit('change', false, network);
                self.networks[network.address] = network;
            }
        } else {
            self.networks[network.address] = network;
            self.emit('appear', false, network);
        }
    };

    // Stop listening
    self.stop = function(callback) {
        self.killing = true;
        clearInterval(self.scanner);
        self.emit('stop', false);
        if (callback) {
            callback();
        }
    };

    // Returns a listing of networks from the last scan
    // Doesn't need a callback, just getting the last list, not doing a new scan
    self.list = function() {
        return self.networks;
    };

    // Enables the interface (ifconfig UP)
    self.enable = function(callback) {
        exec(self.configuration.translated.enable, function(err, stdout, stderr) {
            if (err) {
                console.log("There was an unknown error enabling the interface", err);
                throw err;
            }

            if (stdout || stderr) {
                console.log("There was an error enabling the interface", stdout, stderr);
            }

            if (callback) {
                callback();
            }
        });
    };

    // Disables the interface (ifconfig DOWN)
    self.disable = function(callback) {
        exec(self.configuration.translated.disable, function(err, stdout, stderr) {
            if (err) {
                console.log("There was an unknown error disabling the interface", err);
                throw err;
            }

            if (stdout || stderr) {
                console.log("There was an error disabling the interface", stdout, stderr);
            }

            if (callback) {
                callback();
            }
        });
    };

    // Attempts to connect to the specified network
    self.join = function(ssid, credentials, callback) {

    };

    // Attempts to disconnect from the specified network
    self.leave = function(callback) {

    };

    // Parses the output from `iwlist IFACE scan` and returns a pretty formattted object
    self.parse = function(scanResults) {
        var lines = scanResults.split(/\r\n|\r|\n/);
        var networks = [];
        var network = {};
        var currentTime = new Date();
        _.each(lines, function(line) {
            var line = line.replace(/^\s+|\s+$/g,"");
            // a "Cell" line means that we've found a start of a new network
            if (line.indexOf('Cell') === 0) {
                if (!_.isEmpty(network)) {
                    networks.push(network);
                }
                network = {
                    //speeds: []
                    last_seen: currentTime,
                };
                network.address = line.match(/([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}/)[0];
            } else if (line.indexOf('Channel') === 0) {
                network.channel = line.match(/Channel:([0-9]{1,2})/)[1];
            } else if (line.indexOf('Quality') === 0) {
                network.quality = line.match(/Quality=([0-9]{1,2})\/70/)[1];
            } else if (line.indexOf('Encryption key') === 0) {
                var enc = line.match(/Encryption key:(on|off)/)[1];
                network.encryption = (enc === 'on');
            } else if (line.indexOf('ESSID') === 0) {
                network.ssid = line.match(/ESSID:"(.*)"/)[1];
            } else if (line.indexOf('Mode') === 0) {
                network.mode = line.match(/Mode:(.*)/)[1];
            }
            //else {
                //_.each(line.match(/([0-9]{1,2}|[0-9]{1,2}.[0-9]{1,2}) Mb\/s/g), function(speed) {
                    //console.log(speed);
                    //console.log(parseInt(speed));
                    //network.speeds.push(parseInt(speed), 10);
                //});
            //}
        });
        networks.push(network);

        return networks;
    };

    // Executes a scan, reporting each network we see
    self._executeScan = function() {
        // Make this a non annonymous function, run immediately, then run interval which runs function
        exec(self.configuration.translated.scan, function(err, stdout, stderr) {
            if (err) {
                if (self.killing) {
                    // Of course we got an error the main app is being killed, taking iwlist down with it
                    return;
                }
                console.log("[   ERROR] Got some major errors from our scan command:", err);
                throw err;
            }

            if (stderr) {
                if (stderr.match(/Device or resource busy/)) {
                    console.log("[ WARNING] Scans are overlapping; slow down update frequency");
                    return;
                } else if (stderr.match(/Allocation failed/)) {
                    console.log("[ WARNING] Too many networks for iwlist to handle");
                    return;
                } else {
                    console.log("[ WARNING] Got some errors from our scan command:", stderr);
                }
            }

            if (!stdout) {
                return;
            }

            var content = stdout.toString();
            var networks = self.parse(content);
            _.each(networks, function(network) {
                self._seeNetwork(network);
            });
        });
    };
};

util.inherits(Wireless, events.EventEmitter);
module.exports = new Wireless();
