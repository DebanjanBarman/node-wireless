var util = require('util');
var events = require('events');
var _ = require('underscore');

// gonna require some sys or child_process stuff for executing nix commands
var Wireless = function() {
    events.EventEmitter.call(this);
    var self = this;

    self.networks = [];

    // Configuration settings
    self.configuration = {
        // Interface to listen on (should one day handle multiple)
        iface: 'wlan0',
        // How often to poll the listing of networks
        updateFrequency: 10,
        // What commands to execute
        commands: {
            scan: 'iwlist wlan0',
            stat: 'iwconfig wlan0',
        },
    };

    // Bind us some event listeners!
    //on: function(event, callback) {
        // Events: join/connect, leave/disconnect, change, appear, disappear, scan-complete, scan-start, cracked?
    //},

    // Set the configuration settings
    self.configure = function(config) {
        // should actually be a merge
        self.configuration = config;
    };

    // Start listening
    self.start = function(callback) {
        self.emit('appear', false, {ssid: 'test'});

    };

    // Stop listening
    self.stop = function(callback) {

    };

    // Returns a listing of networks from the last scan
    // Doesn't need a callback, just getting the last list, not doing a new scan
    self.list = function() {

    };

    // Returns a listing of networks from a fresh scan
    self.listAsync = function(callback) {

    };

    // Attempts to connect to the specified network
    self.join = function(ssid, credentials, callback) {

    };

    // Attempts to disconnect from the specified network
    self.leave = function(callback) {

    };

    // Attempts to crack the specifiied network (might not have this since it's evil)
    self.crack = function(ssid, callback) {

    };

    // Parses the output from `iwlist IFACE scan` and returns a pretty formattted object
    self.parse = function(scanResults) {
        var lines = scanResults.split(/\r\n|\r|\n/);
        var networks = [];
        var network = {};
        var currentTime = new Date();
        _.each(lines, function(line) {
            var line = line.replace(/^\s+|\s+$/g,"");
            // a "Cell" line means that we've found a start of a new network
            if (line.indexOf('Cell') === 0) {
                if (!_.isEmpty(network)) {
                    networks.push(network);
                }
                network = {
                    //speeds: []
                    last_seen: currentTime,
                };
                network.address = line.match(/([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}/)[0];
            } else if (line.indexOf('Channel') === 0) {
                network.channel = line.match(/Channel:([0-9]{1,2})/)[1];
            } else if (line.indexOf('Quality') === 0) {
                network.quality = line.match(/Quality=([0-9]{1,2})\/70/)[1];
            } else if (line.indexOf('Encryption key') === 0) {
                var enc = line.match(/Encryption key:(on|off)/)[1];
                network.encryption = (enc === 'on');
            } else if (line.indexOf('ESSID') === 0) {
                network.ssid = line.match(/ESSID:"(.*)"/)[1];
            } else if (line.indexOf('Mode') === 0) {
                network.mode = line.match(/Mode:(.*)/)[1];
            }
            //else {
                //_.each(line.match(/([0-9]{1,2}|[0-9]{1,2}.[0-9]{1,2}) Mb\/s/g), function(speed) {
                    //console.log(speed);
                    //console.log(parseInt(speed));
                    //network.speeds.push(parseInt(speed), 10);
                //});
            //}
        });
        networks.push(network);

        return networks;
    };
};

util.inherits(Wireless, events.EventEmitter);
module.exports = new Wireless();
